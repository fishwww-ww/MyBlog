---
title: FastGPT实习：双Token验证实现CSRF防御
date: 2025-10-12 11:11:25
tags: 实习经历
---

# 双Token验证实现CSRF防御

需求分析：在 FastGPT 平台发现安全漏洞，发送markdown渲染的img标签，如果src属性为"删除api"的路径（如：`/api/core/dataset/delete`），则会将用户的知识库自动删除

通过实现双Token验证机制，有效防御CSRF（跨站请求伪造）攻击

保护用户数据安全，防止恶意站点利用用户身份执行敏感操作

---

## 问题分析

### 漏洞描述

发送markdown渲染的img标签，如果src属性为"删除api"的路径（如：`/api/core/dataset/delete`），则会将用户的知识库自动删除

### 问题本质

由于前端请求自动携带浏览器cookie作为请求头，后端校验通过后，执行图片中的路径，造成CSRF恶意攻击

### 攻击原理

1. 用户已登录平台，浏览器中存储cookie信息
2. 恶意站点的某些表单、图片等请求指向平台的敏感接口
3. 当用户被诱导访问后，浏览器会在请求中自动添加cookie
4. 仅凭Cookie做鉴权的服务端误以为是用户本人操作，执行敏感动作

---

## 解决方案

### 技术方案：双Token验证

#### 实现步骤

1. **前端Token获取**：
   - 前端发送请求前，检测本地存储中没有`csrf_token`，或者过期时间小于阈值时间
   - 主动请求后端生成`csrf_token`，前端接受后解密出token值和过期时间
   - 保存在本地存储中

2. **请求头设置**：
   - 前端在请求前设置`x-csrf-token`请求头
   - 值为本地存储中`csrf_token`的值

3. **后端验证**：
   - 后端收到请求后，从cookie中拿到`csrf_token`
   - 从请求头中拿到`x-csrf-token`
   - 验证两个值是否过期，是否相等
   - 没有问题后再验证通过

4. **自动下发**：
   - 后端检测到请求头没有`x-csrf-token`时，要主动生成token下发给前端

---

## 防御效果

### 成功防御案例

如果添加了双Token验证：

1. 恶意站点与平台不同源，所以读取不到cookie
2. 无法配置cookie和请求头
3. 从而无法通过验证，有效防御CSRF攻击

### 安全机制

- **双重验证**：cookie中的token + 请求头中的token
- **时效性控制**：token具有过期时间
- **同源策略**：恶意站点无法获取有效token

---

## 技术细节

### 重要注意事项

1. **Cookie安全**：
   - 因为要禁止cookie能通过JS脚本获取，所以要给cookie加上`httpOnly`属性
   - 而`csrf_token`值又需要添加到请求头中，所以要在本地存储中存`csrf_token`

2. **避免循环**：
   - 生成`csrf_token`的接口要跳过`csrf_token`的验证
   - 否则会陷入循环请求的死循环中

### 实现优势

- **安全性高**：双重验证机制，有效防御CSRF攻击
- **用户体验好**：自动处理token获取和验证
- **维护性强**：逻辑清晰，易于维护和扩展

---

## 总结

通过实现双Token验证机制，成功解决了FastGPT平台的CSRF安全漏洞

这种防御机制不仅保护了用户数据安全，也为类似的安全问题提供了解决方案

在现代Web应用中，CSRF防御是必不可少的安全措施，双Token验证是一种有效且实用的实现方案
